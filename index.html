<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Policy-Sim (Normalbetrieb)</title>

  <!-- PyScript 2024.x -->
  <link rel="stylesheet" href="https://pyscript.net/releases/2024.6.1/core.css">
  <script defer src="https://pyscript.net/releases/2024.6.1/core.js"></script>

  <style>
    :root { color-scheme: dark; --bg:#0b0d12; --panel:#0f1320; --accent:#2f6feb; }
    *{ box-sizing:border-box }
    body{ margin:0; background:var(--bg); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; color:#d9dde6 }
    header{ padding:14px 18px; border-bottom:1px solid #22283a; display:flex; gap:14px; align-items:center; flex-wrap:wrap }
    header h1{ font-size:18px; margin:0 8px 0 0 }
    select,button,input{ background:#0f1320; border:1px solid #2a3250; color:#d9dde6; padding:8px 10px; border-radius:8px }
    button.primary{ background:var(--accent); border-color:var(--accent); color:white }
    main{ display:grid; grid-template-columns: minmax(0, 1fr) 360px; gap:16px; padding:16px; }
    .panel{ background:var(--panel); border:1px solid #22283a; border-radius:12px; padding:12px }
    .phasebar{ display:flex; gap:8px; flex-wrap:wrap; margin-bottom:8px }
    .chip{ padding:6px 10px; border-radius:999px; border:1px solid #2a3250; font-size:12px }
    .chip.active{ background:#1a2140; color:#7eb0ff; border-color:#385ca8 }
    .scene-title{ font-weight:700; margin:0 0 4px 0 }
    .scene-text{ color:#d9dde6; margin:0 0 10px 0 }
    .actions{ margin-top:10px; display:grid; grid-auto-flow:column; gap:8px; width:max-content }
    .act{ padding:10px; background:#121829; border:1px solid #2a3250; border-radius:8px }
    .infobox h4{ margin:0 0 8px 0; font-size:14px; color:#9fb4ff }
    .infobox ul{ margin:0; padding-left:16px }
    .metrics{ display:grid; gap:8px; margin-top:8px; font-size:14px }
    .barwrap{ background:#0f1320; border:1px solid #2a3250; border-radius:8px; padding:10px; height:40px; position:relative; }
    .bar{ position:absolute; left:0; top:0; bottom:0; background:#2f6feb22; border-right:2px solid #2f6feb }
    .lab{ position:absolute; left:10px; top:10px; font-size:12px; color:#9fb4ff }
    .val{ position:absolute; right:10px; top:10px; font-size:12px; color:#9fb4ff }
    .vote{ margin-top:12px; padding:10px; background:#10162a; border:1px dashed #2a3250; border-radius:10px; font-size:14px }
    @media (max-width:860px){ main{ grid-template-columns: 1fr } }
  </style>
</head>
<body>
  <header>
    <h1>Policy-Sim (Normalbetrieb)</h1>

    <!-- Tempo -->
    <div>
      <label for="speed" style="display:block;font-size:12px;color:#9fb4ff">Tempo</label>
      <select id="speed">
        <option value="0.5">Cinematic (~4 min/Phase)</option>
        <option value="1.0" selected>Normal (~2 min/Phase)</option>
        <option value="2.0">Schnell (~1 min/Phase)</option>
      </select>
    </div>

    <!-- Buttons (py-click = direkt mit Python-Funktionen verbunden) -->
    <div style="display:flex; gap:8px; align-items:center">
  <button id="start"   class="primary" py-click="start_run()">Start</button>
  <button id="skip"    py-click="skip_scene()">Szene überspringen</button>
  <button id="restart" py-click="restart()">Neues Thema</button>
</div>
  </header>

  <main>
    <!-- linkes Panel: Story -->
    <section class="panel">
      <div class="phasebar" id="phasebar"></div>
      <h2 class="scene-title" id="sceneTitle">Willkommen</h2>
      <p class="scene-text" id="sceneText">Wähle ein Thema und starte den Probedurchlauf.</p>
      <div class="actions" id="actions"></div>
      <div class="vote" id="vote" style="display:none"></div>
    </section>

    <!-- rechtes Panel: Info + Dropdown + (Pseudo)-Metriken -->
    <aside class="panel">
      <div class="infobox">
        <h4>Info</h4>
        <ul id="info"></ul>
      </div>

      <div class="metrics" id="metrics"></div>

      <div style="margin-top:10px">
        <label for="topic" style="display:block;font-size:12px;color:#9fb4ff">Thema</label>
        <!-- GENAU EIN select mit id="topic" -->
        <select id="topic" style="width:100%"></select>
      </div>
    </aside>
  </main>


<!-- Fallback: Dropdown-Themen per JavaScript -->
<script>
  const PROBLEM_KEYS = [
    "KI-Regulierung in Behörden",
    "Energiewende & Netzausbau",
    "Wohnungsbau & Mieten",
    "Gesundheitsreform",
    "Cybersicherheit Staat",
    "Schule & Digitalisierung"
  ];

  const sel = document.getElementById("topic");
  if (sel) {
    sel.innerHTML = PROBLEM_KEYS
  .map(k => `<option value="${k}">${k}</option>`)
  .join('');
if (sel.options.length) sel.value = sel.options[0].value;

const info = document.getElementById("info");
if (info) info.innerHTML = `<li>Dropdown geladen – ${sel.options.length} Themen</li>`;
  }
</script>

  <!-- PyScript-Konfiguration (keine extra Packages nötig) -->
  <script type="py-config">
packages = []
  </script>

  <!-- App-Logik (Python) -->
  <script type="py">
from typing import Dict, List, Tuple
from js import document, window
    from pyodide.ffi import create_proxy
import random, math
def by_id(id_: str):
    return document.getElementById(id_)
# ---------- kleine DOM-Hilfen ----------
def by_id(id_: str):
    return document.getElementById(id_)

def set_text(id_: str, txt: str):
    el = by_id(id_)
    if el is not None:
        el.textContent = txt

def set_html(id_: str, html: str):
    el = by_id(id_)
    if el is not None:
        el.innerHTML = html

# ---------- Daten ----------
MBTI = ["ENTJ","INTJ","ENTP","INTP","ENFJ","INFJ","ISTP","ISFJ"]
DISC = [
    "Volkswirtschaft","Public Health","Energiesysteme","Recht",
    "Ethik/Grundrechte","Daten-/IT-Sicherheit","Statistik/Methoden",
    "Verkehr/Infrastruktur","Kommunikation"
]

# Themen → Dropdown-Schlüssel (sichtbar wie geschrieben)
PROBLEMS: Dict[str, List[str]] = {
    "KI-Regulierung in Behörden": ["Daten-/IT-Sicherheit","Ethik/Grundrechte","Recht","Implementierung/Verwaltung"],
    "Energiewende & Netzausbau": ["Energiesysteme","Volkswirtschaft","Recht","Kommunikation"],
    "Wohnungsbau & Mieten":      ["Volkswirtschaft","Recht","Kommunikation"],
    "Gesundheitsreform":         ["Public Health","Volkswirtschaft","Statistik/Methoden"],
    "Cybersicherheit Staat":     ["Daten-/IT-Sicherheit","Recht","Implementierung/Verwaltung"],
    "Schule & Digitalisierung":  ["Implementierung/Verwaltung","Statistik/Methoden","Kommunikation"],
}

# Phase-Erklärungen (Info-Box)
PINFO: Dict[str, List[str]] = {
    "P1": ["Nur FachBEREICHE werden zuerst festgelegt."],
    "P2": ["Thema wird auf Plattform veröffentlicht. Expert:innen bewerben sich."],
    "P3": ["Standard: max. zwei Vertreter:innen je Bereich."],
    "P4": ["Runde 1: Evidenz, Wechselwirkungen, Trade-offs"],
    "P5": ["Politische Abwägung und Entscheidung"],
}

# ---------- Modelle (minimal) ----------
class Agent:
    def __init__(self, name: str, role: str, disc: str, mbti: str):
        self.name = name
        self.role = role
        self.disc = disc
        self.mbti = mbti

def political_pool() -> List[Agent]:
    people: List[Agent] = []
    roles = ["Regierung","Opposition","Verwaltung","Zivilgesellschaft","Wirtschaft","Wissenschaft"]
    for i in range(16):
        people.append(Agent(
            name=f"Person {i+1}",
            role=random.choice(roles),
            disc=random.choice(DISC),
            mbti=random.choice(MBTI),
        ))
    return people

def pick_members(sector_keys: List[str], pool: List[Agent], per_sector: int = 2) -> Dict[str, List[Agent]]:
    """Wählt je Sektor Vertreter aus dem Pool, füllt bei Bedarf nach."""
    out: Dict[str, List[Agent]] = {}
    for d in sector_keys:
        cand = [p for p in pool if p.disc == d]
        rest = [p for p in pool if p.disc != d]
        if len(cand) < per_sector:
            cand = cand + random.sample(rest, k=min(per_sector - len(cand), len(rest)))
        out[d] = random.sample(cand, k=min(per_sector, len(cand)))
    return out

# ---------- Storyboard (Szenen) ----------
def decide(core: Dict[str, List[Agent]]) -> Tuple[str, int, int]:
    """Spielerische Abstimmung: zufälliger Ja-Block 8–14 von 20."""
    yes = random.randint(8, 14)
    tot = 20
    decision = "ADOPT" if yes >= 12 else "REJECT"
    return decision, yes, tot

def storyboard(topic: str, speed: float) -> List[dict]:
    pool = political_pool()
    sectors = PROBLEMS.get(topic, [])
    experts = pick_members(sectors, pool)

    scenes: List[dict] = []

    # P1 — Thema & Bereiche
    lines = [
        f"Gewähltes Thema: {topic}",
        "Fachbereiche werden festgelegt:",
        ", ".join(sectors) if sectors else "(keine Sektoren gefunden)"
    ]
    scenes.append({
        "phase": "P1",
        "title": "Thema & Bereiche",
        "lines": lines,
        "acts": [("Gremium aufbauen","next")]
    })

    # P2 — Gremium bestätigen (zeige ausgewählte Expert:innen)
    explines = [
        f"{d}: " + ", ".join(f"{e.name} ({e.role})" for e in lst)
        for d, lst in experts.items()
    ]
    scenes.append({
        "phase":"P2",
        "title":"Gremium bestätigen",
        "lines":["Ausgewählte Expert:innen:"] + explines,
        "acts":[("Weiter","next")]
    })

    # P3 — Beratungsvorbereitung
    scenes.append({
        "phase":"P3",
        "title":"Evidenz zusammentragen",
        "lines":[
            "Runde 1: Problembeschreibung",
            "Runde 2: Maßnahmenbündel entwickeln"
        ],
        "acts":[("Zur Beratung","next")]
    })

    # P4 — Beratung (Pseudo-Metriken)
    vals = { "Evidenz": random.uniform(0.4, 0.95), "Nebenwirkungen": random.uniform(0.1, 0.6) }
    scenes.append({
        "phase":"P4",
        "title":"Beratung & Evidenz",
        "lines":[
            "Evidenz wird präsentiert und diskutiert.",
            "Metriken werden laufend aktualisiert."
        ],
        "metrics": vals,
        "acts":[("Zur Abstimmung","next")]
    })

    # P5 — Entscheidung
    decision, yes, tot = decide(experts)
    scenes.append({
        "phase":"P5",
        "title":"Politische Entscheidung",
        "lines":[f"Ergebnis: {decision}. Sie stimmen nun ab."],
        "vote": (yes, tot),
        "acts":[("Beenden","end")]
    })

    return scenes

# ---------- Rendering ----------
SCENES: List[dict] = []
idx = -1
timer = None  # (hier nur placeholder für evtl. spätere Timer-Erweiterungen)

def render_phasebar():
    chips: List[str] = []
    for i, s in enumerate(SCENES):
        cls = "chip active" if i == idx else "chip"
        chips.append(f'<span class="{cls}">{s.get("phase","?")}</span>')
    set_html("phasebar", "".join(chips))

def set_info(lines: List[str]):
    set_html("info", "".join(f"<li>{l}</li>" for l in lines))

def set_metrics(vals: Dict[str, float] | None):
    if not vals:
        set_html("metrics","")
        return
    rows: List[str] = []
    for k, v in vals.items():
        pct = max(0, min(100, round(v*100)))
        rows.append(
            f'<div class="barwrap"><div class="bar" style="width:{pct}%"></div>'
            f'<span class="lab">{k}</span><span class="val">{pct}%</span></div>'
        )
    set_html("metrics","".join(rows))

def clear_vote():
    el = by_id("vote")
    el.style.display = "none"
    el.innerHTML = ""

def render_scene():
    s = SCENES[idx]
    set_text("sceneTitle", s.get("title",""))
    set_text("sceneText",  " · ".join(s.get("lines",[])))
    set_metrics(s.get("metrics"))
    # Voting-Box optional
    clear_vote()
    if "vote" in s:
        yes, tot = s["vote"]
        el = by_id("vote")
        el.style.display = "block"
        el.innerHTML = f"Abstimmung: {yes} / {tot} Stimmen JA"
    # Buttons
    acts = s.get("acts",[])
    html = "".join(f'<button class="act" data-key="{k}">{label}</button>' for (label,k) in acts)
    set_html("actions", html)

    # Klicks binden (je Szene neu)
    for btn in document.querySelectorAll("#actions .act"):
        def _handler(evt, key=btn.getAttribute("data-key")):
            if key == "next":
                next_scene()
            elif key == "end":
                finish()
        btn.addEventListener("click", _handler)

    # Info-Leiste zum Phase-Code
    info = PINFO.get(s.get("phase",""), [])
    if info:
        set_info(info)

    render_phasebar()

def next_scene(evt=None):
    global idx
    idx += 1
    if idx >= len(SCENES):
        finish()
        return
    render_scene()

def skip_scene(evt=None):
    next_scene()

def finish():
    set_text("sceneTitle","Ende")
    set_text("sceneText","Danke – Durchlauf abgeschlossen.")
    set_html("actions","")
    set_metrics(None)
    render_phasebar()

def restart(evt=None):
    """Zufälliges Thema übernehmen und UI zurücksetzen."""
    keys = list(PROBLEMS.keys())
    if keys:
        by_id("topic").value = random.choice(keys)
    set_text("sceneTitle","Neuer Durchlauf")
    set_text("sceneText","Thema gewählt, starte neu …")
    set_html("actions","")
    set_metrics(None)
    render_phasebar()
def start_run(evt=None):
    """Startet den Durchlauf — robust & mit sichtbarem Debug."""
    global SCENES, idx, timer
    try:
        # ggf. alten Timer stoppen
        if timer:
            window.clearTimeout(timer)

        # Eingaben holen (robust)
        topic_el = by_id("topic")
        speed_el = by_id("speed")
        topic = topic_el.value if topic_el else ""
        speed = float(speed_el.value) if (speed_el and speed_el.value) else 1.0

        # sichtbares Debug
        set_info([
            f"Start geklickt · Thema: {topic!r}",
            f"Tempo: {speed}"
        ])

        # Szenen bauen
        SCENES = storyboard(topic, speed)
        if not SCENES:
            set_info(["FEHLER: Keine Szenen erzeugt!"])
            return

        # ersten Schritt starten
        idx = -1
        set_info([f"Szenen erzeugt: {len(SCENES)}", "→ Erste Szene wird gerendert …"])
        next_scene()

    except Exception as e:
        set_info([f"START-FEHLER: {e!r}"])
    def bind_buttons():
    """Verbindet Start/Skip/Restart robust mit Python-Funktionen (via Proxy)."""
    try:
        # Proxys erstellen
        _start_proxy   = create_proxy(start_run)
        _skip_proxy    = create_proxy(skip_scene)
        _restart_proxy = create_proxy(restart)

        # Auf window halten, damit sie nicht vom GC eingesammelt werden
        window._start_proxy   = _start_proxy
        window._skip_proxy    = _skip_proxy
        window._restart_proxy = _restart_proxy

        # Event-Listener setzen
        by_id("start").addEventListener("click",   _start_proxy)
        by_id("skip").addEventListener("click",    _skip_proxy)
        by_id("restart").addEventListener("click", _restart_proxy)

        set_info(["Init OK: Buttons verbunden ✅"])
    except Exception as e:
        set_info([f"INIT-FEHLER: {e!r}"])
# ---------- Bootstrap ----------
def populate_topics():
    """Befüllt den Select #topic immer zuverlässig."""
    sel = by_id("topic")
    keys = list(PROBLEMS.keys())
    sel.innerHTML = "".join(f'<option value="{k}">{k}</option>' for k in keys)
    if keys:
        sel.value = keys[0]

# Seite initialisieren
populate_topics()
   bind_buttons() 
set_info(["Dropdown geladen · Themen verfügbar: " + str(len(PROBLEMS))])
document.title = "Policy-Sim ✅"
  </script>
</body>
</html>

