<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Policy-Sim (Normalbetrieb)</title>

  <!-- PyScript 2024.x -->
  <link rel="stylesheet" href="https://pyscript.net/releases/2024.6.1/core.css">
  <script defer src="https://pyscript.net/releases/2024.6.1/core.js"></script>

  <style>
    :root { color-scheme: dark; --bg:#0b0d12; --panel:#0f1320; --accent:#2f6feb; }
    *{ box-sizing:border-box }
    body{ margin:0; background:var(--bg); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; color:#d9dde6 }
    header{ padding:14px 18px; border-bottom:1px solid #22283a; display:flex; gap:14px; align-items:flex-end; flex-wrap:wrap }
    header h1{ font-size:18px; margin:0 8px 0 0 }
    select,button,input{ background:#0f1320; border:1px solid #2a3250; color:#d9dde6; padding:8px 10px; border-radius:8px }
    button.primary{ background:var(--accent); border-color:var(--accent); color:white }
    main{ display:grid; grid-template-columns: minmax(0, 1fr) 360px; gap:16px; padding:16px; }
    .panel{ background:var(--panel); border:1px solid #22283a; border-radius:12px; padding:12px }
    .phasebar{ display:flex; gap:8px; flex-wrap:wrap; margin-bottom:8px }
    .chip{ padding:6px 10px; border-radius:999px; border:1px solid #2a3250; font-size:12px }
    .chip.active{ background:#1a2140; color:#7eb0ff; border-color:#385ca8 }
    .scene-title{ font-weight:700; margin:4px 0 4px 0 }
    .scene-text{ color:#d9dde6; margin:0 0 10px 0 }
    .actions{ margin-top:10px; display:grid; grid-auto-flow:column; gap:8px; width:max-content }
    .act{ padding:10px; background:#121829; border:1px solid #2a3250; border-radius:8px; cursor:pointer }
    .infobox h4{ margin:0 0 8px 0; font-size:14px; color:#9fb4ff }
    .infobox ul{ margin:0; padding-left:16px }
    .metrics{ display:grid; gap:8px; margin-top:8px; font-size:14px }
    .barwrap{ background:#0f1320; border:1px solid #2a3250; border-radius:8px; padding:10px; height:40px; position:relative; }
    .bar{ position:absolute; left:0; top:0; bottom:0; background:#2f6feb22; border-right:2px solid #2f6feb }
    .lab{ position:absolute; left:10px; top:10px; font-size:12px; color:#9fb4ff }
    .val{ position:absolute; right:10px; top:10px; font-size:12px; color:#9fb4ff }
    .vote{ margin-top:12px; padding:10px; background:#10162a; border:1px dashed #2a3250; border-radius:10px; font-size:14px }
    /* Timer-Progress */
    .timer{ margin:6px 0 10px; height:6px; background:#0f1320; border:1px solid #2a3250; border-radius:999px; position:relative; overflow:hidden }
    .timer > i{ position:absolute; inset:0 auto 0 0; width:0; background:var(--accent); opacity:.6; transition:width .25s linear }
    @media (max-width:860px){ main{ grid-template-columns: 1fr } }
  </style>
</head>
<body>
  <header>
    <h1>Policy-Sim (Normalbetrieb)</h1>

    <!-- Tempo -->
    <div>
      <label for="speed" style="display:block;font-size:12px;color:#9fb4ff">Tempo</label>
      <select id="speed" aria-label="Simulationsgeschwindigkeit">
        <option value="0.5">Cinematic (~4 min/Phase)</option>
        <option value="1.0" selected>Normal (~2 min/Phase)</option>
        <option value="2.0">Schnell (~1 min/Phase)</option>
      </select>
    </div>

    <!-- Steuerung -->
    <div style="display:flex; gap:8px; align-items:center">
      <button id="start" class="primary" py-click="start_run">Start</button>
      <button id="auto" aria-pressed="false" py-click="toggle_auto">Auto</button>
      <button id="skip"   py-click="skip_scene">Szene überspringen</button>
      <button id="restart" py-click="restart">Neues Thema</button>
      <button id="export"  py-click="export_run">Export</button>
    </div>

    <!-- Seed (optional) -->
    <div>
      <label for="seed" style="display:block;font-size:12px;color:#9fb4ff">Seed (optional)</label>
      <input id="seed" inputmode="numeric" pattern="[0-9]*" style="width:10ch" placeholder="z. B. 42" />
    </div>
  </header>

  <main>
    <!-- linkes Panel: Story -->
    <section class="panel">
      <div class="phasebar" id="phasebar"></div>

      <!-- Timer-Balken -->
      <div class="timer" id="timer" aria-hidden="true"><i></i></div>

      <h2 class="scene-title" id="sceneTitle" tabindex="-1">Willkommen</h2>
      <p class="scene-text" id="sceneText" role="status" aria-live="polite">Wähle ein Thema und starte den Probedurchlauf.</p>
      <div class="actions" id="actions"></div>
      <div class="vote" id="vote" style="display:none" aria-live="polite"></div>
    </section>

    <!-- rechtes Panel: Info + Dropdown + (Pseudo)-Metriken -->
    <aside class="panel">
      <div class="infobox">
        <h4>Info</h4>
        <ul id="info" role="status" aria-live="polite"></ul>
      </div>

      <div class="metrics" id="metrics"></div>

      <div style="margin-top:10px">
        <label for="topic" style="display:block;font-size:12px;color:#9fb4ff">Thema</label>
        <!-- GENAU EIN select mit id="topic" -->
        <select id="topic" style="width:100%"></select>
      </div>
    </aside>
  </main>

  <!-- PyScript-Konfiguration (keine extra Packages nötig) -->
  <script type="py-config">
packages = []
  </script>

  <!-- App-Logik (Python) -->
  <script type="py">
from typing import Dict, List, Tuple
from dataclasses import dataclass
from js import document
from js import Blob, URL, localStorage
import asyncio
import random
import json

# ---------- kleine DOM-Hilfen ----------
def by_id(id_: str):
    return document.getElementById(id_)

def set_text(id_: str, txt: str):
    el = by_id(id_)
    if el is not None:
        el.textContent = txt

def set_html(id_: str, html: str):
    el = by_id(id_)
    if el is not None:
        el.innerHTML = html

# ---------- Daten ----------
MBTI = ["ENTJ","INTJ","ENTP","INTP","ENFJ","INFJ","ISTP","ISFJ"]
DISC = [
    "Volkswirtschaft","Public Health","Energiesysteme","Recht",
    "Ethik/Grundrechte","Daten-/IT-Sicherheit","Statistik/Methoden",
    "Verkehr/Infrastruktur","Kommunikation","Implementierung/Verwaltung"
]

# Themen → Dropdown-Schlüssel (sichtbar wie geschrieben)
PROBLEMS: Dict[str, List[str]] = {
    "KI-Regulierung in Behörden": ["Daten-/IT-Sicherheit","Ethik/Grundrechte","Recht","Implementierung/Verwaltung"],
    "Energiewende & Netzausbau": ["Energiesysteme","Volkswirtschaft","Recht","Kommunikation"],
    "Wohnungsbau & Mieten":      ["Volkswirtschaft","Recht","Kommunikation"],
    "Gesundheitsreform":         ["Public Health","Volkswirtschaft","Statistik/Methoden"],
    "Cybersicherheit Staat":     ["Daten-/IT-Sicherheit","Recht","Implementierung/Verwaltung"],
    "Schule & Digitalisierung":  ["Implementierung/Verwaltung","Statistik/Methoden","Kommunikation"],
}

# Phase-Erklärungen (Info-Box)
PINFO: Dict[str, List[str]] = {
    "P1": ["Nur FachBEREICHE werden zuerst festgelegt."],
    "P2": ["Thema wird auf Plattform veröffentlicht. Expert:innen bewerben sich."],
    "P3": ["Standard: max. zwei Vertreter:innen je Bereich."],
    "P4": ["Runde 1: Evidenz, Wechselwirkungen, Trade-offs"],
    "P5": ["Politische Abwägung und Entscheidung"],
}

# ---------- Modelle ----------
@dataclass
class Agent:
    name: str
    role: str
    disc: str
    mbti: str

def political_pool() -> List[Agent]:
    people: List[Agent] = []
    roles = ["Regierung","Opposition","Verwaltung","Zivilgesellschaft","Wirtschaft","Wissenschaft"]
    for i in range(16):
        people.append(Agent(
            name=f"Person {i+1}",
            role=random.choice(roles),
            disc=random.choice(DISC),
            mbti=random.choice(MBTI),
        ))
    return people

def pick_members(sector_keys: List[str], pool: List[Agent], per_sector: int = 2) -> Dict[str, List[Agent]]:
    """Wählt je Sektor Vertreter aus dem Pool, füllt bei Bedarf nach."""
    out: Dict[str, List[Agent]] = {}
    for d in sector_keys:
        cand = [p for p in pool if p.disc == d]
        rest = [p for p in pool if p.disc != d]
        if len(cand) < per_sector:
            # aus anderen Disziplinen auffüllen, falls nötig
            need = max(0, per_sector - len(cand))
            if need > 0 and len(rest) > 0:
                cand = cand + random.sample(rest, k=min(need, len(rest)))
        out[d] = random.sample(cand, k=min(per_sector, len(cand))) if cand else []
    return out

# ---------- Storyboard (Szenen) ----------
def decide(core: Dict[str, List[Agent]]) -> Tuple[str, int, int]:
    """Spielerische Abstimmung: zufälliger Ja-Block 8–14 von 20."""
    yes = random.randint(8, 14)
    tot = 20
    decision = "ADOPT" if yes >= 12 else "REJECT"
    return decision, yes, tot

def storyboard(topic: str) -> List[dict]:
    pool = political_pool()
    sectors = PROBLEMS.get(topic, [])
    experts = pick_members(sectors, pool)

    scenes: List[dict] = []

    # P1 — Thema & Bereiche
    lines = [
        f"Gewähltes Thema: {topic}",
        "Fachbereiche werden festgelegt:",
        ", ".join(sectors) if sectors else "(keine Sektoren gefunden)"
    ]
    scenes.append({
        "phase": "P1",
        "title": "Thema & Bereiche",
        "lines": lines,
        "acts": [("Gremium aufbauen","next")]
    })

    # P2 — Gremium bestätigen (zeige ausgewählte Expert:innen)
    explines = [
        f"{d}: " + ", ".join(f"{e.name} ({e.role})" for e in lst) if lst else f"{d}: (keine Auswahl)"
        for d, lst in experts.items()
    ]
    scenes.append({
        "phase":"P2",
        "title":"Gremium bestätigen",
        "lines":["Ausgewählte Expert:innen:"] + explines,
        "acts":[("Weiter","next")]
    })

    # P3 — Beratungsvorbereitung
    scenes.append({
        "phase":"P3",
        "title":"Evidenz zusammentragen",
        "lines":[
            "Runde 1: Problembeschreibung",
            "Runde 2: Maßnahmenbündel entwickeln"
        ],
        "acts":[("Zur Beratung","next")]
    })

    # P4 — Beratung (Pseudo-Metriken)
    vals = { "Evidenz": random.uniform(0.4, 0.95), "Nebenwirkungen": random.uniform(0.1, 0.6) }
    scenes.append({
        "phase":"P4",
        "title":"Beratung & Evidenz",
        "lines":[
            "Evidenz wird präsentiert und diskutiert.",
            "Metriken werden laufend aktualisiert."
        ],
        "metrics": vals,
        "acts":[("Zur Abstimmung","next")]
    })

    # P5 — Entscheidung
    decision, yes, tot = decide(experts)
    scenes.append({
        "phase":"P5",
        "title":"Politische Entscheidung",
        "lines":[f"Ergebnis: {decision}. Sie stimmen nun ab."],
        "vote": (yes, tot),
        "acts":[("Beenden","end")]
    })

    return scenes

# ---------- Rendering & State ----------
SCENES: List[dict] = []
idx = -1

def render_phasebar():
    chips: List[str] = []
    for i, s in enumerate(SCENES):
        cls = "chip active" if i == idx else "chip"
        chips.append(f'<span class="{cls}">{s.get("phase","?")}</span>')
    set_html("phasebar", "".join(chips))

def set_info(lines: List[str]):
    set_html("info", "".join(f"<li>{l}</li>" for l in lines))

def set_metrics(vals: Dict[str, float] | None):
    if not vals:
        set_html("metrics","")
        return
    rows: List[str] = []
    for k, v in vals.items():
        pct = max(0, min(100, round(v*100)))
        rows.append(
            f'<div class="barwrap"><div class="bar" style="width:{pct}%"></div>'
            f'<span class="lab">{k}</span><span class="val">{pct}%</span></div>'
        )
    set_html("metrics","".join(rows))

def clear_vote():
    el = by_id("vote")
    el.style.display = "none"
    el.innerHTML = ""

def render_scene():
    s = SCENES[idx]
    set_text("sceneTitle", s.get("title",""))
    set_text("sceneText",  " · ".join(s.get("lines",[])))
    set_metrics(s.get("metrics"))
    clear_vote()

    # Interaktive Vote-Box (falls vorhanden)
    if "vote" in s:
        yes, tot = s["vote"]
        el = by_id("vote")
        el.style.display = "block"
        el.innerHTML = (
            "<div><strong>Abstimmung</strong> · "
            f"{tot} Stimmen Gesamt</div>"
            '<div style="margin-top:8px">'
            '<label><input type="radio" name="myvote" value="yes" checked> Ja</label> '
            '<label><input type="radio" name="myvote" value="no"> Nein</label> '
            '<button id="cast" class="act" type="button">Meine Stimme abgeben</button>'
            '<span id="voteres" style="margin-left:8px;color:#9fb4ff"></span>'
            '</div>'
        )
        def _cast(evt, base_yes=yes, total=tot):
            sel = document.querySelector('input[name="myvote"]:checked')
            my_yes = 1 if (sel and sel.value == "yes") else 0
            new_yes = base_yes + my_yes
            result = "ADOPT" if new_yes >= 12 else "REJECT"
            set_html("voteres", f"Ergebnis: {new_yes} / {total} JA → {result}")
        by_id("cast").addEventListener("click", _cast)

    # Buttons rendern & Clicks binden
    acts = s.get("acts",[])
    html = "".join(f'<button class="act" data-key="{k}">{label}</button>' for (label,k) in acts)
    set_html("actions", html)

    for btn in document.querySelectorAll("#actions .act"):
        def _handler(evt, key=btn.getAttribute("data-key")):
            if key == "next":
                next_scene()
            elif key == "end":
                finish()
        btn.addEventListener("click", _handler)

    # Info-Leiste zum Phase-Code
    info = PINFO.get(s.get("phase",""), [])
    set_info(info if info else [])

    render_phasebar()

    # Fokus auf erste Aktion
    first_btn = document.querySelector("#actions .act")
    if first_btn:
        first_btn.focus()

def next_scene(evt=None):
    global idx
    idx += 1
    if idx >= len(SCENES):
        finish()
        return
    render_scene()

def skip_scene(evt=None):
    next_scene()

def finish():
    global auto_running
    auto_running = False
    by_id("auto").setAttribute("aria-pressed","false")
    set_text("sceneTitle","Ende")
    set_text("sceneText","Danke – Durchlauf abgeschlossen.")
    set_html("actions","")
    set_metrics(None)
    clear_vote()
    render_phasebar()

# ---------- Auto-Modus (Tempo & Timer) ----------
auto_running = False

def get_speed_factor() -> float:
    try:
        return float(by_id("speed").value) or 1.0
    except Exception:
        return 1.0

def get_phase_seconds() -> int:
    # Normalbetrieb: ~120s pro Phase; Speed skaliert linear (min. 5s)
    return max(5, int(120 / get_speed_factor()))

async def _timer_loop(duration: int):
    """Füllt den Timer-Balken visuell über 'duration' Sekunden."""
    barwrap = by_id("timer")
    bar = barwrap.firstElementChild if barwrap else None
    if barwrap:
        barwrap.setAttribute("aria-hidden", "false")
    t = 0
    while auto_running and t < duration:
        pct = int((t / duration) * 100)
        if bar:
            bar.style.width = f"{pct}%"
        await asyncio.sleep(1)
        t += 1
    if bar:
        bar.style.width = "0%"
    if barwrap:
        barwrap.setAttribute("aria-hidden", "true")

async def _auto_loop():
    """Automatischer Durchlauf – schaltet nach Ablauf der Phase weiter."""
    global auto_running
    while auto_running and 0 <= idx < len(SCENES):
        dur = get_phase_seconds()
        # Timer und Wartezeit parallel ausführen
        timer_task = asyncio.create_task(_timer_loop(dur))
        try:
            await asyncio.sleep(dur)
        finally:
            try:
                timer_task.cancel()
            except Exception:
                pass
        if not auto_running:
            break
        next_scene()
    auto_running = False
    by_id("auto").setAttribute("aria-pressed","false")

def toggle_auto(evt=None):
    """Auto-Modus ein/aus."""
    global auto_running
    # Ohne laufende Scenes zuerst starten
    if not SCENES:
        start_run()
    if idx < 0:
        next_scene()
    auto_running = not auto_running
    by_id("auto").setAttribute("aria-pressed", "true" if auto_running else "false")
    if auto_running:
        asyncio.create_task(_auto_loop())

# ---------- Start/Restart/Export ----------
def restart(evt=None):
    """Zufälliges Thema übernehmen und UI sauber zurücksetzen."""
    global SCENES, idx, auto_running
    auto_running = False
    by_id("auto").setAttribute("aria-pressed","false")
    keys = list(PROBLEMS.keys())
    if keys:
        by_id("topic").value = random.choice(keys)
    SCENES = []
    idx = -1
    clear_vote()
    set_text("sceneTitle","Neuer Durchlauf")
    set_text("sceneText","Thema gewählt – bereit zum Start.")
    set_html("actions","")
    set_metrics(None)
    render_phasebar()

def start_run(evt=None):
    """Startet den Durchlauf – robust & mit Debug-Info in der Info-Box."""
    global SCENES, idx, auto_running
    try:
        # optionaler Seed
        try:
            seed_txt = by_id("seed").value.strip()
            if seed_txt:
                random.seed(int(seed_txt))
        except Exception:
            # Ignorieren, wenn kein valider Seed
            pass

        topic = by_id("topic").value
        SCENES = storyboard(topic)
        idx = -1
        auto_running = False
        by_id("auto").setAttribute("aria-pressed","false")
        set_info([
            f"Start geklickt · Thema: {topic}",
            f"Szenen erzeugt: {len(SCENES)}"
        ])
        next_scene()
    except Exception as e:
        set_info([f"START-FEHLER: {e!r}"])

def export_run(evt=None):
    """Exportiert das aktuelle Storyboard als JSON-Download."""
    try:
        data = {
            "topic": by_id("topic").value,
            "scenes": SCENES,
        }
        blob = Blob.new([json.dumps(data, ensure_ascii=False, indent=2)], { "type": "application/json" })
        url = URL.createObjectURL(blob)
        a = document.createElement("a")
        a.href = url
        a.download = f"policy-sim_{by_id('topic').value.replace(' ','_')}.json"
        a.click()
        URL.revokeObjectURL(url)
        set_info(["Export erstellt."])
    except Exception as e:
        set_info([f"EXPORT-FEHLER: {e!r}"])

# ---------- Persistenz (Thema/Tempo) ----------
def save_prefs():
    try:
        prefs = {"topic": by_id("topic").value, "speed": by_id("speed").value}
        localStorage.setItem("policy-sim:prefs", json.dumps(prefs))
    except Exception:
        pass

def load_prefs():
    try:
        raw = localStorage.getItem("policy-sim:prefs")
        if raw:
            p = json.loads(str(raw))
            if "speed" in p:
                by_id("speed").value = str(p["speed"])
            if "topic" in p and p["topic"] in PROBLEMS:
                by_id("topic").value = p["topic"]
    except Exception:
        pass

# ---------- Bootstrap ----------
def populate_topics():
    """Befüllt den Select #topic immer zuverlässig."""
    sel = by_id("topic")
    keys = list(PROBLEMS.keys())
    sel.innerHTML = "".join(f'<option value="{k}">{k}</option>' for k in keys)
    if keys:
        sel.value = keys[0]

# Seite initialisieren
populate_topics()
load_prefs()
set_info(["Dropdown geladen · Themen verfügbar: " + str(len(PROBLEMS))])
document.title = "Policy-Sim ✅"

# Präferenzen speichern, wenn Auswahl geändert wird
by_id("topic").addEventListener("change", lambda evt: save_prefs())
by_id("speed").addEventListener("change", lambda evt: save_prefs())
  </script>
</body>
</html>
